//Лабиринт "Пирамида"

namespace Mazes
{
	public static class PyramidMazeTask
	{
        static void MoveUp(Robot robot) //метод шагания вверх
        {
            int moveCount = 0;              //обнуляется счётчик шагов вправо
            while (moveCount < 2)           //поскольку все стенки толщиной в одну клетку - на каждом повороте роботу нужно сделать 2 шага вверх
            {
                robot.MoveTo(Direction.Up);  //шагает вправо на одну клетку
                moveCount++;                 //прибавляется к количеству шагов еще один
            }
        }

        static void MoveRight(Robot robot, int width) //метод шагания вправо
        {
            int moveCount = 0;                   //обнуляется счётчик шагов вправо
            while (moveCount < (width - 3))      //нужно сделать на три шага меньше, чем ширина лабиринта - минус три - это правая и левая стенки + клетка, на 
                                                 //которой стоит робот
            {
                robot.MoveTo(Direction.Right);   //шагает вправо на одну клетку
                moveCount++;                     //прибавляется к количеству шагов еще один
            }
        }

        static void MoveLeft(Robot robot, int width)  //метод шагания влево
        {
            int moveCount = 0;                  //обнуляется счётчик шагов влево
            while (moveCount < (width - 3))     //нужно сделать на три шага меньше, чем ширина лабиринта - минус три - это правая и левая стенки + клетка, на 
                                                //которой стоит робот
            {
                robot.MoveTo(Direction.Left);   //шагает влево на одну клетку
                moveCount++;                    //прибавляется к количеству шагов еще один
            }
        }

        public static void MoveOut(Robot robot, int width, int height)
        {
            int count = 0;              //обнуляется счётчик пройденных строчек
            width += 2;                 //прибавляем к ширине 2 - чтобы не делать исключение для первой строчки лабиринта
                                        //наверняка существует более лаконичное решение, но это пришло в голову в первую очередь, было очень навязчиво и не уходило
            while (count < height - 1)  //пока количество пройденных строчек меньше `высота минус единица` - так как судьба нижней границы лабиринта нас не волнует - 
                                        //её мы сразу вычтем, а о верхней позаботимся позже
            {
                width -= 2;             //вычитаем двойку из ширины каждый раз перед шаганием вправо, так так каждый раз длина пути уменьшается на две клетки
                MoveRight(robot, width);//вызывается метод шагания вправо
                MoveUp(robot);          //вызывается метод шагания вниз
                width -= 2;             //вычитаем двойку из ширины каждый раз перед шаганием влево, так так каждый раз длина пути уменьшается на две клетки
                MoveLeft(robot, width); //вызывается метод шагания влево
                count += 4;             //к количеству пройденных строчек прибавляется 4 (три фактически пройденных + верхняя граница) - учитывается здесь, а  не вместе
                                        //с нижней, так как для каждого поворота будет своя верхняя граница (как один из вариантов, допускаю, что не самый простой)
                if (count < height - 1) //если количество пройденных строчек меньше, чем `высота минус единица`, то 
                    MoveUp(robot);      //вызывается метод шагания вверх
            }
        }
    }
}